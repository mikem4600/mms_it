/*
* ============================================================================
*  Name     : CMMS_ItAppUi from MMS_ItAppUi.cpp
*  Part of  : MMS_It
*  Created  : 29/9/2003 by Makidis Michael
*  Implementation notes:
*     Initial content was generated by Series 60 AppWizard.
*  Copyright: Makidis Michael 2003-2005
* ============================================================================
*/

// INCLUDE FILES
#include "MMS_ItAppUi.h"
#include "MMS_ItView.h"
#include "MMS_ItView2.h"
#include "MMS_ItView3.h"
#include <MMS_IT.RSG>
#include "mms_it.hrh"

#include "MMS_ItContainer.h"
#include "MMS_ItContainer2.h"
#include "MMS_ItContainer3.h"
#include "MMS_ItDocument.h"

#include <avkon.hrh>

#include <aknmessagequerydialog.h> // for query dialog
#include <stringloader.h>  // for StringLoader
#include <aknnotewrappers.h> // for notes

#include <CPbkContactEngine.h> // for the phone book engine
#include <rpbkviewresourcefile.h> // for RPbkViewResourceFile
#include <CPbkMultipleEntryFetchDlg.h> // for the multiple phone fetch dlg
#include <cntdb.h> // for CContactDatabase
#include <cpbkmmsaddressselect.h>  // for CPbkMmsAddressSelect
#include <cpbkcontactitem.h> // for CPbkContactItem

// MMS
#include <mtclreg.h>                        // for CClientMtmRegistry 
#include <msvids.h>                         // for Message type IDs
#include <mmsclient.h>                      // for CMmsClientMtm





// ================= MEMBER FUNCTIONS =======================

CMMS_ItAppUi::CMMS_ItAppUi(CMMS_ItDocument *aDocument)
:	iNaviDecorator(NULL), iDocument(aDocument)
{

}

//
// ----------------------------------------------------------
// CMMS_ItAppUi::ConstructL()
// ?implementation_description
// ----------------------------------------------------------
//
void CMMS_ItAppUi::ConstructL()
    {
    BaseConstructL(
#ifdef SERIES_60_V2
		EAknEnableSkin
#endif
		);

	// Show tabs for main views from resources
    CEikStatusPane* sp = StatusPane();

    // Fetch pointer to the default navi pane control
    iNaviPane = (CAknNavigationControlContainer*)sp->ControlL( 
        TUid::Uid(EEikStatusPaneUidNavi));

    ShowDefaultNaviPaneL();

    iView1 = new (ELeave) CMMS_ItView(this);

    CleanupStack::PushL( iView1 );
    iView1->ConstructL();
    AddViewL( iView1 );      // transfer ownership to CAknViewAppUi
    CleanupStack::Pop();    // view1

	iView2 = new (ELeave) CMMS_ItView2(iDocument, this);

    CleanupStack::PushL( iView2 );
    iView2->ConstructL();
    AddViewL( iView2 );      // transfer ownership to CAknViewAppUi
    CleanupStack::Pop();    // view2

	iView3 = new (ELeave) CMMS_ItView3(iDocument, this);

    CleanupStack::PushL( iView3 );
    iView3->ConstructL();
    AddViewL( iView3 );      // transfer ownership to CAknViewAppUi
    CleanupStack::Pop();    // view3

    SetDefaultViewL(*iView1);

	// Create CMsvSession
    iSession = CMsvSession::OpenAsyncL(*this); // new session is opened asynchronously
                                               // CompleteConstructL() is called when async finishes

    }

void CMMS_ItAppUi::CompleteConstructL()
{
	// We get a MtmClientRegistry from our session
	// this registry is used to instantiate new mtms.
	iMtmReg = CClientMtmRegistry::NewL(*iSession);
	iMmsMtm = (CMmsClientMtm*) iMtmReg->NewMtmL( KUidMsgTypeMultimedia );

	// notify the user with a InfoWin (this will be shown in emulator only)
	iEikonEnv->InfoMsg(_L("Server session opened."));
}

// ----------------------------------------------------
// CMMS_ItAppUi::~CMMS_ItAppUi()
// Destructor
// Frees reserved resources
// ----------------------------------------------------
//
CMMS_ItAppUi::~CMMS_ItAppUi()
    {
	delete iMmsMtm;
	delete iMtmReg;

	delete iSession;    // session must be deleted last (and constructed first)

    delete iNaviDecorator;
	}

// ------------------------------------------------------------------------------
// CMMS_ItAppUi::::DynInitMenuPaneL(TInt aResourceId,CEikMenuPane* aMenuPane)
//  This function is called by the EIKON framework just before it displays
//  a menu pane. Its default implementation is empty, and by overriding it,
//  the application can set the state of menu items dynamically according
//  to the state of application data.
// ------------------------------------------------------------------------------
//
void CMMS_ItAppUi::DynInitMenuPaneL(
    TInt /*aResourceId*/,CEikMenuPane* /*aMenuPane*/)
    {
    }

// ----------------------------------------------------
// CMMS_ItAppUi::HandleKeyEventL(
//     const TKeyEvent& aKeyEvent,TEventCode /*aType*/)
// ?implementation_description
// ----------------------------------------------------
//
TKeyResponse CMMS_ItAppUi::HandleKeyEventL(
    const TKeyEvent& /*aKeyEvent*/,TEventCode /*aType*/)
    {
		return EKeyWasNotConsumed;
    }

// ----------------------------------------------------
// CMMS_ItAppUi::HandleCommandL(TInt aCommand)
// ?implementation_description
// ----------------------------------------------------
//
void CMMS_ItAppUi::HandleCommandL(TInt aCommand)
    {
    switch ( aCommand )
        {
		case EAknSoftkeyExit:
        case EExit:
            {
			CAknQueryDialog* confirmDialog = CAknQueryDialog::NewL(CAknQueryDialog::ENoTone);
			if (confirmDialog->ExecuteLD(R_MMS_IT_CONFIRM_EXIT_DIALOG))
				Exit();
            break;
            }
		case ENewMessage:
			{
			// remove all components of current message
			iView2->HandleCommandL(ERemoveSubject);
			iView2->HandleCommandL(ESetDefaultSMIL);
			iDocument->ResetAttachments();
			iDocument->iMessageText.Zero();
			
			// switch to 2nd view
            ActivateLocalViewL(KView2Id);

			iView2->UpdateContainer();
			break;
			}
		case EAknSoftkeyBack:
		case EShowBody:
			{
			// switch to 2nd view
            ActivateLocalViewL(KView2Id);
			break;
			}
		case EShowAttachments:
			{
			// switch to 3nd view
            ActivateLocalViewL(KView3Id);
			break;
			}
		case ESend:
			{
			SendMessageL();
			break;
			}
		case ESendwManualAddr:
			{
			SendMessageL(EFalse);
			break;
			}
        case EDisplayHelp:
			{
			// load the resources and display the about box
			HBufC* textResource = StringLoader::LoadLC(R_MMS_IT_HELP);
			HBufC* textResource2 = StringLoader::LoadLC(R_MMS_IT_HELP_ABOUT);
			CAknMessageQueryDialog* dlg = CAknMessageQueryDialog::NewL(*textResource);
			dlg->PrepareLC(R_MESSAGE_QUERY);
			dlg->QueryHeading()->SetTextL(*textResource2);
			dlg->RunLD();
			CleanupStack::PopAndDestroy(textResource2);
			CleanupStack::PopAndDestroy(textResource);
            break;
			}
        default:
            break;      
        }
    }

void CMMS_ItAppUi::ShowDefaultNaviPaneL()
{
	CEikStatusPane* sp=iEikonEnv->AppUiFactory()->StatusPane();
	CAknNavigationControlContainer* np= (CAknNavigationControlContainer *)sp->ControlL(TUid::Uid(EEikStatusPaneUidNavi));
	np->PushDefaultL (); // Set default.
	delete iNaviDecorator;
	iNaviDecorator = NULL;
	//DrawNow();
}

void CMMS_ItAppUi::ShowAtNaviPanelL(TPtrC aText)
{
	CEikStatusPane* sp=iEikonEnv->AppUiFactory()->StatusPane();
	CAknNavigationControlContainer* np= (CAknNavigationControlContainer *)sp->ControlL(TUid::Uid(EEikStatusPaneUidNavi));

	delete iNaviDecorator;
	iNaviDecorator = NULL;

	iNaviDecorator = np->CreateNavigationLabelL(aText);

	np->PushL(*iNaviDecorator);
	//DrawNow();
}

void CMMS_ItAppUi::HandleSessionEventL
	(TMsvSessionEvent aEvent, TAny* /*aArg1*/, TAny* /*aArg2*/, TAny* /*aArg3*/)
    {
    switch (aEvent)
        {
            // This event tells us that the session has been opened
        case EMsvServerReady:
            CompleteConstructL();       // Construct the mtm registry & MMS mtm
            break;

        default:
            // All other events are ignored
            break;
        }

    }

TBool CMMS_ItAppUi::SendMessageL(TBool aUsePbForAddresses)
    {

	/*
	 * Validate attachments
	 */
	for(TInt i = 0; i < iDocument->CountAttachments(); i++)
	{
		if(!iDocument->FileExists(iDocument->GetAttachment(i)->iFilename))
		{
			HBufC* textResource = StringLoader::LoadLC(R_ATTACHMENT_NOT_FOUND);
			CAknErrorNote* note = new (ELeave) CAknErrorNote();
			note->ExecuteLD(*textResource);
			CleanupStack::PopAndDestroy(textResource);
			return EFalse;
		}
	}
	if(iDocument->SMILAttSet() && !iDocument->FileExists(iDocument->GetSMILFilename()))
		{
			HBufC* textResource = StringLoader::LoadLC(R_SMIL_ATTACHMENT_NOT_FOUND);
			CAknErrorNote* note = new (ELeave) CAknErrorNote();
			note->ExecuteLD(*textResource);
			CleanupStack::PopAndDestroy(textResource);
			return EFalse;
		}

	/*
	 * Get the adressees from the user (gsm numbers or E-Mail addrs)
	 */
	if(aUsePbForAddresses)
	{		
		//Create a new phone book engine object and connect to the default contact database
		CPbkContactEngine* pbkContactEngine = CPbkContactEngine::NewL();
		CleanupStack::PushL( pbkContactEngine );
		TBool AtLeastOneAddrAdded = EFalse;

		RPbkViewResourceFile  phonebookResource( *(CEikonEnv::Static())  );

		if ( !phonebookResource.IsOpen())
			{
			phonebookResource.OpenL();
			}

		// Add searching array to parameters
		CContactDatabase::TContactViewFilter filterSMS(CContactDatabase::ESmsable);
		CContactDatabase::TContactViewFilter filterEMail(CContactDatabase::EMailable); 
		CPbkMultipleEntryFetchDlg::TParams params;
		params.iContactView = &pbkContactEngine->FilteredContactsViewL( filterSMS | filterEMail ); 
    
		// Launch fetching dialog
		CPbkMultipleEntryFetchDlg* fetchDlg = CPbkMultipleEntryFetchDlg::NewL( params, *pbkContactEngine );
		fetchDlg->SetMopParent( this );  
		TInt okPressed = fetchDlg->ExecuteLD();
		CleanupStack::PushL( params.iMarkedEntries );

		if ( okPressed )
			{
			// Process the marked entries
			TInt paramCount = params.iMarkedEntries->Count();
			// Get the selected contacts id array
			for ( TInt i = 0; i < paramCount; ++i )
				{
				const TContactItemId cid = ( *params.iMarkedEntries )[i];
            
				// Open the selected contact using Phonebook engine,
				// choose correct number (launch list query if needed)
				CPbkContactItem* pbkItem = pbkContactEngine->ReadContactLC( cid );
				TPtrC recAddress;
            
				CPbkMmsAddressSelect* selectDlg = new (ELeave)CPbkMmsAddressSelect( );
				recAddress.Set( selectDlg->ExecuteLD(*pbkItem, pbkItem->DefaultMmsField(), ETrue) );

				if(recAddress != KNullDesC)
				{
					if(AtLeastOneAddrAdded)
					{
						// just add the adressee
						iMmsMtm->AddAddresseeL( recAddress );
					}
					else // this is the first valid adressee
					{
						AtLeastOneAddrAdded = ETrue;

						// Set up the MSV entry
						CMsvEntry* entry = CMsvEntry::NewL(*iSession, KMsvGlobalOutBoxIndexEntryId ,TMsvSelectionOrdering());
						CleanupStack::PushL(entry);

						// Set context to the parent folder (Outbox) & create message
						iMmsMtm->SwitchCurrentEntryL( entry->EntryId() );
						iMmsMtm->CreateMessageL( iMmsMtm->DefaultSettingsL() );

						CleanupStack::PopAndDestroy(); // entry
						
						iMmsMtm->AddAddresseeL( recAddress );
					}
				}

				CleanupStack::PopAndDestroy(pbkItem);
				}
			}

		CleanupStack::PopAndDestroy();  // iMarkedEntries
		phonebookResource.Close();	   // Close the phonebook view
		CleanupStack::PopAndDestroy(pbkContactEngine);

		if(!okPressed || !AtLeastOneAddrAdded) return EFalse;

	}
	else
	{
		// Get the recipient address
		TBuf<100> RecipientAddress;  // for recipient address (gsm number or E-Mail addr)
		CAknTextQueryDialog* telNumDialog = CAknTextQueryDialog::NewL(RecipientAddress, CAknQueryDialog::ENoTone);
		if (!telNumDialog->ExecuteLD(R_MMS_IT_TEL_NUMBER_DIALOG))
			return EFalse;

		// Set up the entry
		CMsvEntry* entry = CMsvEntry::NewL(*iSession, KMsvGlobalOutBoxIndexEntryId ,TMsvSelectionOrdering());
		CleanupStack::PushL(entry);

		// Set context to the parent folder (Outbox) & create message
		iMmsMtm->SwitchCurrentEntryL( entry->EntryId() );
		iMmsMtm->CreateMessageL( iMmsMtm->DefaultSettingsL() );
		CleanupStack::PopAndDestroy(); // entry

		// Setting recipient
		iMmsMtm->AddAddresseeL( RecipientAddress );
	}



	/*
	 * Setting attachments (message parts)
	 */
	TMsvId attachmentID;

	attachmentID = KMsvNullIndexEntryId;
	iMmsMtm->CreateTextAttachmentL( attachmentID, iDocument->iMessageText );

	for(TInt u = 0; u < iDocument->CountAttachments(); u++)
	{
		attachmentID = KMsvNullIndexEntryId;
		if(!iDocument->SMILAttSet())
		{
			iMmsMtm->CreateAttachment2L( attachmentID, iDocument->GetAttachment(u)->iFilename );
		}
		else
		{
			iMmsMtm->CreateAttachmentL( attachmentID, iDocument->GetAttachment(u)->iFilename );
		}
		if(iDocument->GetAttachment(u)->iMIMETypeSet)
		{
			iMmsMtm->SetAttachmentTypeL( attachmentID, iDocument->GetAttachment(u)->iMIMEType );
		}
	}

	if(iDocument->SMILAttSet())
	{
		attachmentID = KMsvNullIndexEntryId;
		iMmsMtm->CreateAttachment2L( attachmentID, iDocument->GetSMILFilename() );
		iMmsMtm->SetMessageRootL( attachmentID );

	}

	if(iDocument->SubjectSet())
	{
		iMmsMtm->SetSubjectL ( iDocument->GetSubject() );

	}

	/*
	 * Send the message
	 */
    // Set InPreparation to false
    TMsvEntry ent = iMmsMtm->Entry().Entry();
    ent.SetInPreparation(EFalse);
    ent.SetVisible(ETrue);            // mark as visible, after this the message can be seen in Outbox and, after sending, in Sent folder.
    iMmsMtm->Entry().ChangeL(ent);    // Commit changes

	// Save changes (or else all changes made will be lost when the context is changed.)
    iMmsMtm->SaveMessageL();

	// Notify the user
	HBufC* textResource = StringLoader::LoadLC(R_MESSAGE_SENT);
	CAknConfirmationNote* note = new (ELeave) CAknConfirmationNote();
	note->ExecuteLD(*textResource);
	CleanupStack::PopAndDestroy(textResource);
    
    // Start sending the message via the Server MTM to the MMS server
    CMsvOperationWait* wait = CMsvOperationWait::NewLC(); // left in CS
    wait->iStatus = KRequestPending;
    CMsvOperation* op = NULL;
    op = iMmsMtm->SendL( wait->iStatus );
    wait->Start();
    CleanupStack::PushL( op );
    CActiveScheduler::Start();

    // The following is to ignore the completion of other active objects. It is not
    // needed if the app has a command absorbing control.
    while( wait->iStatus.Int() == KRequestPending )
        {
        CActiveScheduler::Start();
        }

    CleanupStack::PopAndDestroy(2); // op, wait

    return ETrue;
    }

// End of File  
